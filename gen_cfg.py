#!/usr/bin/python3
import re
import sys
import argparse
import collections


def printToFile(file, key, items):
    f.write("[{}]\n".format(key))
    for key,value in items.items():
        f.write("{}={}\n".format(key,value))   
    f.write("\n\n")     

text = 'This programs extracts the address in the header file generated by the FPGA C API, and generates an ini template for EPICS.'

header = '; Automatically generated ini file for CRIO library\n\
; The settings required to setup the CRIO environment are here\n\
; - Destination Crio IP: The IP address of the target CRIO\n\
;                        For safety, our intention is to keep this\n\
;                        IP as the loopback address (127.0.0.1)\n\
; - Path: is the path to the bitfile that will be used to configure\n\
;         the FPGA of the target CRIO.\n\
; - Bitfile Name: Is the name of the bitfile\n\
; - Signature: Is the signature of that specific bitfile\n\
; - Use Shared Memory: Set to 1 if labviewRT will open a shared memory\n\
; - Shared Memory Path: If Use Shared Memory is set to 1, then this path\n\
;                       will be used.\n\
\n\
;\n\
;Naming Considerations:\n\
;    RT Variables:\n\
;        The keyword RT_ is reserved for variables that are defined \n\
;        in labview RT. Do not use this reserved word in your names\n\
;        unless it is an RT variable, otherwise it will be ignored!\n\
;        Keywords for realtime double, single, signed 8, 16, 32, 64 \n\
;        and unsigned 8, 16, 32, 64 are defined as follows\n\
;        Double          : RT_DBL_<NAME>\n\
;        Single          : RT_SGL_<NAME>\n\
;        Unsigned 64 bit : RT_U64_<NAME>\n\
;        Unsigned 32 bit : RT_U32_<NAME>\n\
;        Unsigned 16 bit : RT_U16_<NAME>\n\
;        Unsigned 08 bit : RT_U08_<NAME>\n\
;        Signed 64 bit   : RT_I64_<NAME>\n\
;        Signed 32 bit   : RT_I32_<NAME>\n\
;        Signed 16 bit   : RT_I16_<NAME>\n\
;        Signed 08 bit   : RT_I08_<NAME>\n\
;\n\
;    FPGA variables naming:\n\
;        FPGA variables must have one of the following keywords:\n\
;        AI, AO, BI, BO \n\
;\n\
;\n\
;Checks implemented in the library:\n\
; Checking for same address / index within a category has been\n\
; implemented. An exception is throw upon occurance.\n\
\n\
\n\
\n\n'


# initiate the parser
parser = argparse.ArgumentParser()

# Input parameters
parser.add_argument("input",  help="Name of input header file to be processed.")
parser.add_argument("useSM", help="Use shared memory. 0=not use, 1=use", type=int)
parser.add_argument("binaryInputs", help="Number of binary inputs.")
parser.add_argument("--output", "-o", default="cfg.ini", help="Name of output ini file to be generated.")
parser.add_argument("--ip", help="Destination IP of the CRIO", default = '127.0.0.1')
parser.add_argument("--path", help="Bitfile path", default = '/change/me/')
parser.add_argument("--sourceFilesFolder", "-s", help="Folder containing all files necessary for ini generation", default = '.')
parser.add_argument("--bfname", help="Bitfile name", default = 'NiFpga_CrioLinux.lvbitx')
parser.add_argument("--smfname", help="Shared memory file path and name", default = '/labview_linux_sm')



# read arguments from the command line
args = parser.parse_args()

# read header file
with open(args.input) as f:
    lines = f.readlines()

if (args.useSM !=0 and args.useSM != 1):
    print("useSM parameter must be 0 or 1.")
    parser.print_help()
    sys.exit(2)    
    
# *.ini key dictionaries
settings = {'Destination Crio IP' : args.ip,
            'Path':args.path,
            'Bitfile Name': args.bfname,
            'Use Shared Memory': args.useSM,
            'Shared Memory Path': args.smfname}
biaddr = {}
boaddr = {}
aoaddr = {}
aiaddr = {}
bilist = []
rtlist = []
bidict = collections.OrderedDict()

rtvarCount = 0;
fpgavarCount = 0;

for line in lines:
    result = re.search('_Signature\s*=\s*\"([A-F0-9]{32})\"', line)
    if (result is not None):
        settings['Signature']=(result.group(1))
    else:
        result = re.search('IndicatorU64_(BI[a-zA-Z0-9]*) = 0x([A-F0-9]{5})', line)
        if (result is not None):
            biaddr[result.group(1)]=(result.group(2))
            fpgavarCount += 1
            #found BI. Parse associated BI file.
            bi = result.group(1)
            bilist = [bi.rstrip() for bi in open('{}/{}.list'.format(args.sourceFilesFolder, bi))]
            bidict = { i : bilist[i] for i in range(0, len(bilist) ) }
        else:
            result = re.search('IndicatorSgl_(Mod[a-zA-Z0-9]*) = 0x([A-F0-9]{5})', line)
            if (result is not None):
                aiaddr[result.group(1)]=(result.group(2))
                fpgavarCount += 1                
            else:
                result = re.search('ControlSgl_(Mod[a-zA-Z0-9]*) = 0x([A-F0-9]{5})', line)
                if (result is not None):
                    aoaddr[result.group(1)]=(result.group(2))         
                    fpgavarCount += 1
                else:
                    result = re.search('ControlBool_(Mod[a-zA-Z0-9]*) = 0x([A-F0-9]{5})', line)
                    if (result is not None):
                        boaddr[result.group(1)]=(result.group(2))                              
                        fpgavarCount += 1


#process RT variables if enabled
if (args.useSM == 1):
    rtlist = [rt.rstrip() for rt in open('{}/RT.list'.format(args.sourceFilesFolder))]
    for i, val in enumerate(rtlist):
        result = re.search('RT_[A-Z0-9]{3}_AO', val)
        if (result is not None):
            aoaddr[val]=i 
            rtvarCount += 1
        result = re.search('RT_BOL_BO', val)
        if (result is not None):
            boaddr[val]=i
            rtvarCount += 1            
        result = re.search('RT_[A-Z0-9]{3}_AI', val)
        if (result is not None):
            aiaddr[val]=i
            rtvarCount += 1            
        result = re.search('RT_BOL_BI', val)
        if (result is not None):
            biaddr[val]=i
            rtvarCount += 1            

    
print( "{} RT variables processed\n{} FPGA addresses extracted".format(rtvarCount, fpgavarCount))
with open(args.output , "w") as f:
    f.write(header)
    printToFile(f, 'Settings', settings)
    printToFile(f, 'BIAddresses', biaddr)
    printToFile(f, bi, bidict)
    printToFile(f, 'AO', aoaddr)
    printToFile(f, 'AI', aiaddr)
    printToFile(f, 'BO', boaddr)

    
       


